import fs from "node:fs";
import path from "node:path";
import {
  generateSpaceCSSVariables,
  generateTypeCSSVariables,
} from "./font-size.ts";
import {
  latinTypeConfig,
  latinSpaceConfig,
  cjkTypeConfig,
  cjkSpaceConfig,
} from "./configs/type-config.ts";
import fontMetrics from "./font-metrics.json";

// Constants
const DEFAULT_OUTPUT_PATH = path.resolve("css/_typography.css");
const SUPPORTED_SCRIPTS = ["latin", "cjk"] as const;
type ScriptType = (typeof SUPPORTED_SCRIPTS)[number];

interface ScriptConfig {
  type: typeof latinTypeConfig;
  space: typeof latinSpaceConfig;
}

const scriptConfigs: Record<ScriptType, ScriptConfig> = {
  latin: { type: latinTypeConfig, space: latinSpaceConfig },
  cjk: { type: cjkTypeConfig, space: cjkSpaceConfig },
};

interface GenerateOptions {
  outputPath?: string;
}

/**
 * Namespaces CSS variables with a given prefix
 * @param variables - CSS variable definitions
 * @param namespace - Namespace prefix to add
 * @returns Namespaced CSS variables
 * @throws {Error} If variables or namespace are invalid
 */
export function namespaceVariables(
  variables: string,
  namespace: string,
): string {
  if (!variables?.trim() || !namespace?.trim()) {
    throw new Error("Variables and namespace must be non-empty strings");
  }

  return variables
    .split("\n")
    .map((line) => {
      const trimmedLine = line.trim();
      if (trimmedLine.startsWith("/*") || trimmedLine === "") return line;
      return line.replace(/--(fs|space)-/g, `--${namespace}-$1-`);
    })
    .join("\n");
}

/**
 * Generates CSS variables for a specific script configuration
 * @param script - Script type ('latin' or 'cjk')
 * @returns Generated CSS variables
 */
function generateScriptVariables(script: ScriptType) {
  const config = scriptConfigs[script];

  const typeVars = namespaceVariables(
    generateTypeCSSVariables(config.type),
    script,
  );

  const spaceVars = namespaceVariables(
    generateSpaceCSSVariables(config.space),
    script,
  );

  return { typeVars, spaceVars };
}

/**
 * Generates semantic variable mappings for a script
 * @param script - Script type to generate variables for
 * @returns Generated semantic variables
 */
export function generateSemanticVariables(
  script: ScriptType = "latin",
): string {
  const config = scriptConfigs[script];
  const {
    type: { typeLabels },
    space: { spaceLabels },
  } = config;

  const typeVars = typeLabels
    .map((label) => `  --fs-${label}: var(--${script}-fs-${label});`)
    .join("\n");

  const spaceVars = spaceLabels
    .map((label) => `  --space-${label}: var(--${script}-space-${label});`)
    .join("\n");

  return `${typeVars}\n\n${spaceVars}`;
}

/**
 * Generates CSS for font metrics
 * @returns Generated font metrics CSS
 */
function generateFontMetricsCSS(): string {
  const metrics = Object.entries(fontMetrics)
    .map(
      ([font, metrics]) => `
  --${font}-distance-top: ${metrics.ascent - metrics.capHeight};
  --${font}-distance-top: ${Math.abs(metrics.descent)};`, // it's easier to subtract the margins if this is a positive instead of negative value.
    )
    .join("\n");

  return metrics.trim();
}

/**
 * Generates the complete CSS content
 * @returns Generated CSS content
 */
export function generateCSS(): string {
  const latinVars = generateScriptVariables("latin");
  const cjkVars = generateScriptVariables("cjk");

  const semanticVars = generateSemanticVariables("latin");
  const semanticCJKVars = generateSemanticVariables("cjk");
  const fontMetricsVars = generateFontMetricsCSS();

  return `/* 
* DO NOT EDIT THIS FILE DIRECTLY. 
* Your changes will be overwritten. This file is auto-generated. 
* Generated on: ${new Date().toISOString()}
*/
  
:root {
  /* Latin Typography Variables */
${latinVars.typeVars}

  /* Latin Spacing Variables */
${latinVars.spaceVars}

  /* CJK Typography Variables */
${cjkVars.typeVars}
  --cjk-lh: calc(1em + 1rem);

  /* CJK Spacing Variables */
${cjkVars.spaceVars}

  /* Font Metrics */
  ${fontMetricsVars}

  /* Semantic Variables (Default to Latin) */
${semanticVars}
}

/* CJK Overrides */
html[lang="ja"] {
  /* Semantic Variables (CJK) */
${semanticCJKVars}
}

`.trim();
}

/**
 * Writes CSS content to a file
 * @param css - CSS content to write
 * @param outputPath - Path to write the CSS file
 * @returns Promise that resolves when the file is written
 */
export async function writeCSS(
  css: string,
  outputPath: string = DEFAULT_OUTPUT_PATH,
): Promise<void> {
  try {
    await fs.promises.mkdir(path.dirname(outputPath), { recursive: true });
    await fs.promises.writeFile(outputPath, css);
    console.log(`CSS variables generated successfully at ${outputPath}`);
  } catch (error) {
    throw new Error(
      `Failed to write CSS file to ${outputPath}: ${error instanceof Error ? error.message : "Unknown error"}`,
    );
  }
}

/**
 * Generates and writes CSS content to a file
 * @param options - Generation options
 * @returns Promise that resolves when the CSS is generated and written
 */
export async function generateAndWriteCSS(
  options: GenerateOptions = {},
): Promise<void> {
  try {
    const css = generateCSS();
    await writeCSS(css, options.outputPath);
    console.log("CSS generation complete.");
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    console.error("Failed to generate or write CSS:", message);
    throw error;
  }
}

// Main execution
if (require.main === module) {
  generateAndWriteCSS().catch((error) => {
    console.error(error);
    process.exit(1);
  });
}

// Add the generateScales function
export function generateScales() {
  const latinTypeVars = generateTypeCSSVariables(latinTypeConfig);
  const latinSpaceVars = generateSpaceCSSVariables(latinSpaceConfig);
  const cjkTypeVars = generateTypeCSSVariables(cjkTypeConfig);
  const cjkSpaceVars = generateSpaceCSSVariables(cjkSpaceConfig);

  return {
    typeSizes: {
      ...latinTypeVars,
      ...cjkTypeVars,
    },
    spaceSizes: {
      ...latinSpaceVars,
      ...cjkSpaceVars,
    },
  };
}
