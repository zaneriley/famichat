# ADR 004: Refresh Token Rotation for Device Revocation

**Date**: 2025-10-05
**Status**: Proposed
**Deciders**: [Pending]
**Priority**: High (Sprint 9)

---

## Context

Phoenix.Token (current implementation) has significant limitations for production authentication:

1. **Cannot be revoked**: Tokens are stateless (signed but not stored). If device is compromised, token remains valid until expiration.
2. **Fixed expiration**: 24-hour TTL is too long for security, too short for UX (forces frequent re-login).
3. **No device management**: Cannot list active sessions, cannot revoke specific devices.
4. **No refresh mechanism**: User must re-enter credentials every 24 hours.

**Security Risk**: Stolen token grants 24-hour access with no ability to revoke.

**User Impact**: Poor UX (frequent re-login) and security vulnerability (cannot revoke compromised devices).

---

## Problem Statement

**Goal**: Enable secure, long-lived sessions with device revocation capability.

**Requirements**:
1. Long-lived refresh tokens (30+ days)
2. Short-lived access tokens (5-15 minutes)
3. Device revocation (user can revoke specific devices)
4. Session management (user can see all active devices)
5. Automatic token rotation (refresh tokens rotate on use)
6. Theft detection (invalidate token family if stolen token used)

---

## Decision

Implement **refresh token rotation** with device tracking.

### Components

1. **Access Token** (Short-lived, stateless)
   - JWT or Phoenix.Token
   - Lifetime: 5-15 minutes
   - Claims: user_id, device_id, issued_at
   - Used for all API requests

2. **Refresh Token** (Long-lived, stateful)
   - Cryptographically random (not JWT)
   - Lifetime: 30 days
   - Stored in database (enables revocation)
   - Rotates on every use (old token invalidated)

3. **Device Tracking**
   - `user_devices` table (device_id, user_id, refresh_token_hash, last_active, user_agent)
   - User can view all active devices
   - User can revoke specific devices

### Flow

```
1. Login
   → Server generates access token (15min) + refresh token (30d)
   → Refresh token stored in database
   → Client stores both tokens

2. API Request
   → Client sends access token
   → Server validates token (stateless)
   → If expired → Client uses refresh token

3. Token Refresh
   → Client sends refresh token
   → Server validates refresh token (database lookup)
   → Server generates new access token + new refresh token
   → Server invalidates old refresh token
   → Client stores new tokens

4. Device Revocation
   → User clicks "Revoke" on device
   → Server deletes refresh token from database
   → Device cannot refresh access token
   → Next API request fails (403 Unauthorized)
```

### Theft Detection

If old (rotated) refresh token is used:
1. Server detects token has been rotated
2. Server invalidates entire token family (all refresh tokens for that device)
3. User must re-authenticate
4. Prevents stolen token from being used

---

## Alternatives Considered

### Alternative 1: Phoenix.Token Only (Current)

**Pros**: Simple, no database storage
**Cons**: Cannot revoke, fixed expiration, no device management

**Rejected**: Security vulnerability too severe for production.

---

### Alternative 2: Guardian Library

**Pros**: Battle-tested, implements token rotation, widely used in Elixir ecosystem
**Cons**: Heavy dependency, opinionated architecture

**Decision**: Defer. Evaluate Guardian if custom implementation proves complex.

---

### Alternative 3: Pow Library

**Pros**: Designed for Phoenix, includes user management
**Cons**: Very heavy dependency, includes features we don't need (password reset, registration, etc.)

**Rejected**: Too opinionated, we want custom user management.

---

## Implementation Plan

### Database Schema

```elixir
# priv/repo/migrations/[timestamp]_create_user_devices.exs
create table(:user_devices) do
  add :user_id, references(:users, on_delete: :delete_all), null: false
  add :device_id, :string, null: false  # UUID generated by client
  add :refresh_token_hash, :string, null: false  # SHA256(refresh_token)
  add :previous_token_hash, :string  # For theft detection
  add :user_agent, :string  # Browser/app info
  add :ip_address, :string  # Login IP
  add :last_active_at, :utc_datetime, null: false
  add :revoked_at, :utc_datetime  # Soft delete

  timestamps()
end

# Indexes
create unique_index(:user_devices, [:device_id])
create index(:user_devices, [:user_id])
create index(:user_devices, [:refresh_token_hash])
```

### Token Generation

```elixir
defmodule Famichat.Accounts.TokenService do
  @access_token_ttl 15 * 60  # 15 minutes (seconds)
  @refresh_token_ttl 30 * 24 * 60 * 60  # 30 days (seconds)

  def generate_tokens(user, device_id, user_agent, ip_address) do
    # Generate access token (stateless)
    access_token = Phoenix.Token.sign(
      FamichatWeb.Endpoint,
      "user_access",
      %{user_id: user.id, device_id: device_id},
      max_age: @access_token_ttl
    )

    # Generate refresh token (stateful)
    refresh_token = :crypto.strong_rand_bytes(32) |> Base.url_encode64()
    refresh_token_hash = :crypto.hash(:sha256, refresh_token) |> Base.encode16(case: :lower)

    # Store refresh token in database
    {:ok, device} = Repo.insert(%UserDevice{
      user_id: user.id,
      device_id: device_id,
      refresh_token_hash: refresh_token_hash,
      user_agent: user_agent,
      ip_address: ip_address,
      last_active_at: DateTime.utc_now()
    })

    %{
      access_token: access_token,
      refresh_token: refresh_token,
      access_token_expires_in: @access_token_ttl,
      refresh_token_expires_in: @refresh_token_ttl
    }
  end

  def refresh_tokens(refresh_token) do
    # Hash incoming token
    token_hash = :crypto.hash(:sha256, refresh_token) |> Base.encode16(case: :lower)

    # Find device by token hash
    case Repo.get_by(UserDevice, refresh_token_hash: token_hash, revoked_at: nil) do
      nil ->
        # Token not found or revoked
        {:error, :invalid_token}

      device ->
        # Check if token is expired
        if token_expired?(device.last_active_at, @refresh_token_ttl) do
          {:error, :expired_token}
        else
          # Rotate token
          user = Repo.get!(User, device.user_id)
          new_tokens = generate_tokens(user, device.device_id, device.user_agent, device.ip_address)

          # Update device with new token hash (stores previous for theft detection)
          Repo.update!(Ecto.Changeset.change(device,
            previous_token_hash: token_hash,
            refresh_token_hash: :crypto.hash(:sha256, new_tokens.refresh_token) |> Base.encode16(case: :lower),
            last_active_at: DateTime.utc_now()
          ))

          # Delete old device record (old token invalidated)
          # Note: We keep previous_token_hash for theft detection

          {:ok, new_tokens}
        end
    end
  end

  def revoke_device(user_id, device_id) do
    case Repo.get_by(UserDevice, user_id: user_id, device_id: device_id) do
      nil -> {:error, :not_found}
      device ->
        Repo.update!(Ecto.Changeset.change(device, revoked_at: DateTime.utc_now()))
        {:ok, :revoked}
    end
  end

  defp token_expired?(last_active, ttl) do
    DateTime.diff(DateTime.utc_now(), last_active, :second) > ttl
  end
end
```

### Channel Authentication Update

```elixir
# lib/famichat_web/channels/user_socket.ex
def connect(%{"token" => token}, socket, _connect_info) do
  case Phoenix.Token.verify(
    FamichatWeb.Endpoint,
    "user_access",
    token,
    max_age: 15 * 60  # 15 minutes
  ) do
    {:ok, %{user_id: user_id, device_id: device_id}} ->
      # Verify device is not revoked
      case Repo.get_by(UserDevice, device_id: device_id, revoked_at: nil) do
        nil -> :error
        _device -> {:ok, assign(socket, :user_id, user_id)}
      end

    {:error, _reason} ->
      :error
  end
end
```

---

## Security Considerations

### Token Storage (Client-Side)

**Access Token**: Store in memory only (not localStorage or cookies)
- Lost on app restart (acceptable, short-lived)
- Prevents XSS theft

**Refresh Token**: Store in secure storage
- iOS: Keychain
- Android: EncryptedSharedPreferences
- Web: HttpOnly cookie (not accessible to JavaScript)

### Token Transmission

**Access Token**: Authorization header (`Authorization: Bearer <token>`)
**Refresh Token**: HttpOnly cookie (web) or request body (mobile)

### Theft Detection

If previous refresh token is used (after rotation):
1. Log security event
2. Invalidate all tokens for device
3. Notify user of suspicious activity (optional)

---

## Performance Impact

**Database Queries**:
- Token refresh: 1 SELECT + 1 UPDATE (~5ms)
- Channel connect: 1 additional SELECT for device verification (~2ms)
- Device list: 1 SELECT per user session (~5ms)

**Total Impact**: <10ms per request (negligible within 200ms budget)

---

## Migration Strategy

1. **Sprint 9**: Implement token rotation, deploy to development
2. **Sprint 10**: Test with real devices, verify revocation works
3. **Sprint 11**: Deploy to production (requires users to re-login)

**Breaking Change**: Existing Phoenix.Token sessions will be invalidated. Users must re-login.

---

## Consequences

### Positive

1. **Security**: Device revocation prevents unauthorized access
2. **UX**: Long-lived sessions (30 days), no frequent re-login
3. **Compliance**: Required for production security standards
4. **Device Management**: Users can see and manage all active devices

### Negative

1. **Complexity**: Adds database table, token rotation logic
2. **Performance**: Additional database query per channel connect (~2ms)
3. **Storage**: Refresh tokens stored in database (grows over time, needs cleanup)

### Neutral

1. **Implementation Time**: ~1 sprint (2 weeks)
2. **Testing**: Requires device revocation testing (multi-device setup)

---

## Open Questions

1. **Token Cleanup**: How to clean up expired/revoked tokens? (Background job every 7 days?)
2. **Rate Limiting**: Should we rate-limit token refresh attempts? (Yes, prevent brute force)
3. **Guardian Integration**: Should we reconsider Guardian library if custom implementation proves complex?

---

## References

- [OWASP Token Storage Best Practices](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)
- [RFC 6749: OAuth 2.0 Refresh Tokens](https://datatracker.ietf.org/doc/html/rfc6749#section-1.5)
- [Phoenix.Token Documentation](https://hexdocs.pm/phoenix/Phoenix.Token.html)
- [Guardian Library](https://github.com/ueberauth/guardian)

---

**Last Updated**: 2025-10-05
**Next Review**: Sprint 9 (after implementation)
