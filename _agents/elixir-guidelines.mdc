---
description: 
globs: 
alwaysApply: true
---
# Role
**Expert Senior Elixir Engineer**

## Tech Stack
- **Language:** Elixir
- **Framework:** Phoenix
- **Database:** PostgreSQL
- **Containerization:** Docker
- **CSS Framework:** Tailwind CSS
- **Tools:**
  - LeftHook
  - Sobelow
  - Credo
  - Ecto
  - ExUnit
  - Plug
  - Phoenix LiveView
  - Phoenix LiveDashboard
  - Gettext
  - Jason
  - Swoosh
  - Finch
  - DNS Cluster
  - Release Please
  - ExCoveralls
  - Ueberauth (for OAuth integration)

## Code Writing Guidelines
- DO NOT PUT @moduledocs on the outside of modules.
-- BAD:
```elixir
@moduledoc """
A simple Plug for debugging connection details in test/dev environments.
It logs information about the connection at various points in a pipeline.
"""
defmodule PushSearchWeb.DebugPlug do
  import Plug.Conn
  require Logger

  def init(opts), do: opts

end
```
-- GOOD:
```elixir
defmodule PushSearchWeb.DebugPlug do
@moduledoc """
A simple Plug for debugging connection details in test/dev environments.
It logs information about the connection at various points in a pipeline.
"""
  import Plug.Conn
  require Logger

  def init(opts), do: opts

end
```
- Always think through all considerations and requirements before writing any code.
- Follow Test-Driven Development (TDD) principles: write tests first, then implement functionality to make them pass, and finally refactor.
- Pay close attention to compiler warnings and debug logs; they often provide direct clues to underlying issues.

## Predicate Function Naming Convention
- **Rule:** Predicate functions should never start with "is" and must always end with a question mark.
- **Example:** Instead of naming a function `is_empty/1`, name it `empty?/1`.

## Phoenix Router Best Practices

### 1. Route Order and Specificity
- **Rule:** Define specific routes (e.g., `/auth/logout`) *before* more generic routes with path parameters (e.g., `/auth/:provider`) within the same scope or at the same path depth.
- **Bad Example:**
  ```elixir
  # This scope might incorrectly match "/auth/logout" as "/auth/:provider"
  # with "logout" being treated as the provider.
  scope "/auth" do
    pipe_through :browser
    get "/:provider", PushSearchWeb.AuthController, :request
    get "/:provider/callback", PushSearchWeb.AuthController, :callback
    get "/logout", PushSearchWeb.SessionController, :logout # This might not be reached as intended
  end
  ```
- **Good Example:**
  ```elixir
  scope "/auth" do
    pipe_through :browser
    get "/logout", PushSearchWeb.SessionController, :logout # Specific route first
    get "/:provider", PushSearchWeb.AuthController, :request
    get "/:provider/callback", PushSearchWeb.AuthController, :callback
  end
  ```
- **Why:** The Phoenix router matches routes in the order they are defined. Generic patterns can unintentionally "capture" more specific paths if they are defined earlier in the router configuration, leading to requests not reaching the intended controller action.

### 2. Controller Module Resolution in Scopes
- **Rule:** When using `scope "/path", MyAppWeb do` and referencing controllers, be mindful of how Phoenix resolves module names to avoid `Controller.init/1 is undefined` errors due to incorrect namespacing.
- **Recommendation for Clarity (Option A):** Remove the application's web module from the `scope` definition (e.g., use `scope "/path" do`) and always use the full module name for controllers within that scope.
  ```elixir
  # In router.ex
  # alias PushSearchWeb.Admin.UserController # Alias can still be used elsewhere in the module for convenience

  scope "/admin" do # No PushSearchWeb module here
    pipe_through :browser
    get "/users", PushSearchWeb.Admin.UserController, :index # Use the full module name
  end
  ```
- **Alternative (Option B - Use with caution):** If you keep the web module in the scope (e.g., `scope "/admin", PushSearchWeb do`), ensure controller names referenced inside (e.g., `Admin.UserController`) correctly resolve to the intended module (e.g., `PushSearchWeb.Admin.UserController`) without creating a double namespace (like `PushSearchWeb.PushSearchWeb.Admin.UserController`). This often means avoiding simple aliases for controllers if they conflict with the implicit namespacing of the scope.
  ```elixir
  # In router.ex
  # No alias like `alias PushSearchWeb.Admin.UserController, as: UserController` if it creates confusion here

  scope "/admin", PushSearchWeb do # PushSearchWeb module is part of the scope
    pipe_through :browser
    # Assumes Phoenix will correctly combine "PushSearchWeb" from the scope
    # with "Admin.UserController" to find PushSearchWeb.Admin.UserController.
    get "/users", Admin.UserController, :index
  end
  ```
- **Why:** Incorrect namespacing or module resolution issues are a common source of "undefined function" or "module not available" errors at compile time or during application startup. Using full module names within scopes that *don't* specify the base web module (Option A) is generally less ambiguous and easier to debug. Compiler warnings often hint at these issues (e.g., seeing `MyAppWeb.MyAppWeb.MyController.init/1 is undefined`).

## LiveView Optimizations

### General Instruction
Optimize Phoenix LiveView components to minimize HTML diffs by following best practices in component rendering and state management.

### Guidelines

#### 1. Avoid Patterns That Prevent Effective Change Tracking
- **Description:** Avoid patterns such as passing entire assigns or using problematic access that hinders efficient HTML diffing.
- **Bad Examples:**
  ```elixir
  <%= assigns[:greetings] %>
  <%= assigns.greetings %>
  <.hello_component {assigns} />
  <.hello_component greeting={assigns[:greeting]} person={assigns[:person]} />
  <%= hello_component(assigns) %>
  <%= render WelcomeView, "hello.html", assigns %>
  ```
- **Recommendation:** Use function components with explicit assigns:
  ```elixir
  <.hello_component greeting={@greeting} person={@person} />
  ```

#### 2. Avoid Defining Local Variables in HEEx Templates
- **Description:** Do not define local variables within HEEx templates or pass unnecessary assigns to child components.
- **Bad Examples:**
  ```elixir
  <% some_var = @x + @y %>
  <%= some_var %>
  ```
  and:
  ```elixir
  def render(assigns) do
    sum = assigns.x + assigns.y
    title = assigns.title

    ~H"<h1><%= title %></h1>
    <%= sum %>"
  end
  ```
- **Recommendation:** Compute values using helper functions and pass only required assigns:
  ```elixir
  def render(assigns) do
    assigns = assign(assigns, sum: assigns.x + assigns.y, title: assigns.title)

    ~H"""
    <h1><%= @title %></h1>
    <%= @sum %>
    """
  end
  ```

#### 3. Use Function-Based Computations in HEEx Templates
- **Description:** Incorporate helper function-based computations within HEEx templates and LiveView render functions to enhance change tracking and rendering efficiency.
- **Good Examples:**
  ```elixir
  defp sum(x, y), do: x + y

  <%= sum(@x, @y) %>

  def render(assigns) do
    assigns = assign(assigns, sum: sum(assigns.x, assigns.y))

    ~H"""
    <h1><%= @title %></h1>
    <%= @sum %>
    """
  end

  attr :x, :integer, required: true
  attr :y, :integer, required: true
  attr :title, :string, required: true

  def sum_component(assigns) do
    assigns = assign(assigns, sum: sum(assigns.x, assigns.y))

    ~H"""
    <h1><%= @title %></h1>
    <%= @sum %>
    """
  end
  ```
- **Recommendation:** Manage assigns using `assign/2`, `assign_new/3`, and `update/3` to ensure efficient rendering.


**Credo Rules: Do's and Don'ts**

**1. `Credo.Check.Design.TagTODO` (TODO Comments)**

*   **Goal:** Ensure TODO comments represent actionable items and aren't left indefinitely.
*   **DON'T:**
    ```elixir
    # TODO: Fix this later when I have time
    # TODO: Implement feature X (no ticket reference)
    def problematic_function(arg) do
      # ... temporary hack ...
    end
    ```
*   **DO:**
    *   Address the TODO promptly.
    *   If it can't be done immediately, create a ticket/issue in your tracking system and reference it.
    *   Remove obsolete TODOs.
    ```elixir
    # TODO: Refactor this logic - See JIRA-123 / GitHub Issue #45
    def function_to_refactor(arg) do
      # ... current implementation ...
    end

    # Or, if the TODO was addressed:
    def refactored_function(arg) do
      # ... improved implementation ...
    end
    ```
*   **Why:** Prevents codebase clutter with stale comments and ensures necessary work is properly tracked and prioritized.

**2. `Credo.Check.Readability.PredicateFunctionNames` (Boolean Function Naming)**

*   **Goal:** Use standard Elixir naming conventions for functions returning booleans (`true`/`false`).
*   **DON'T:**
    ```elixir
    def is_valid(user) do ... end
    def check_permissions(user, resource) do ... end # Doesn't signal boolean return
    def has_items(list) do ... end
    ```
*   **DO:**
    *   End the function name with a question mark (`?`).
    *   Avoid prefixes like `is_`, `has_`.
    ```elixir
    def valid?(user) do ... end
    def allowed?(user, resource) do ... end
    def empty?(list) do ... end # Note: often better to check Enum.empty? directly
    def contains_item?(list, item) do ... end
    ```
*   **Why:** Idiomatic Elixir; clearly signals the function returns `true` or `false`, improving readability at the call site (e.g., `if valid?(user)` is clearer than `if is_valid(user)`).

**3. `Credo.Check.Refactor.NegatedConditionsInIf` (Using `if !condition` or `if not condition`)**

*   **Goal:** Improve readability by avoiding negated conditions in `if` statements where simpler alternatives exist.
*   **DON'T:**
    ```elixir
    # Simple negation
    if !is_nil(user) do
      # user exists
    end

    # Negation with else
    if not File.exists?(path) do
      Logger.error("File missing!")
      {:error, :not_found}
    else
      File.read(path)
    end
    ```
*   **DO:**
    *   Use `unless` for simple negations without an `else` block.
    *   For `if/else`, rewrite using a positive condition, potentially swapping the `if/else` blocks.
    ```elixir
    # Simple negation -> unless
    unless is_nil(user) do
      # user exists
    end
    # Or even better if checking non-nil specifically:
    if user do
      # user exists
    end

    # Negation with else -> positive condition
    if File.exists?(path) do
      File.read(path)
    else
      Logger.error("File missing!")
      {:error, :not_found}
    end
    ```
*   **Why:** `unless` reads more naturally for simple negations. Positive conditions in `if` statements are generally easier to parse mentally than negative ones (`if file exists` is simpler than `if not (file does not exist)`).

**4. `Credo.Check.Refactor.MapJoin` (Using `Enum.map |> Enum.join`)**

*   **Goal:** Use the more efficient and concise `Enum.map_join/3`.
*   **DON'T:**
    ```elixir
    users |> Enum.map(&(&1.name)) |> Enum.join(", ")
    ```
*   **DO:**
    ```elixir
    Enum.map_join(users, ", ", &(&1.name))
    ```
*   **Why:** `Enum.map_join` performs the mapping and joining in a single pass over the collection, which is more efficient than creating an intermediate list with `Enum.map` and then iterating again with `Enum.join`. It's also more idiomatic.

**5. `Credo.Check.Refactor.WithClauses` (Non-`<-` clauses in `with` head)**

*   **Goal:** Keep the `with` "head" focused on the "happy path" pattern matching, moving side effects or non-matching calls into the `do` block.
*   **DON'T:**
    ```elixir
    with {:ok, user} <- Repo.get(User, id),
         Logger.info("Fetched user #{user.id}"), # Side effect in head
         {:ok, posts} <- fetch_posts(user),
         count = Enum.count(posts) # Non-matching assignment in head
    do
      {:ok, user, posts, count}
    else
      # error handling
    end
    ```
*   **DO:**
    ```elixir
    with {:ok, user} <- Repo.get(User, id),
         {:ok, posts} <- fetch_posts(user)
    do
      Logger.info("Fetched user #{user.id}") # Side effect in `do` block
      count = Enum.count(posts)             # Assignment in `do` block
      {:ok, user, posts, count}
    else
      # error handling
    end
    ```
*   **Why:** Improves readability by clearly separating the successful path conditions (`<-`) from actions or calculations performed after success. Makes the flow easier to follow.

**Bonus Common Rules:**

**6. `Credo.Check.Warning.UnsafeToAtom` (Using `String.to_atom/1`)**

*   **Goal:** Prevent potential Denial-of-Service attacks by exhausting the VM's atom table.
*   **DON'T:**
    ```elixir
    key = String.to_atom(user_provided_string) # DANGEROUS if input is external
    Map.get(data, key)
    ```
*   **DO:**
    *   Use `String.to_existing_atom/1` if you *know* the atom should already exist (safer, raises if not).
    *   Explicitly map allowed string inputs to known atoms.
    ```elixir
    # Safer option if atom MUST exist
    key = String.to_existing_atom(user_provided_string)
    Map.get(data, key)

    # Safest option: Explicit mapping
    key = case user_provided_string do
      "admin" -> :admin
      "user" -> :user
      _ -> :guest # Default or error
    end
    Map.get(data, key)
    ```
*   **Why:** The number of atoms in an Erlang VM is limited (though the limit is large). If an attacker can force the creation of millions of unique atoms via external input, they can crash the VM. `String.to_existing_atom/1` avoids creating *new* atoms.
